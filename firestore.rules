rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    // Helper Functions
    function isOwner(userId) {
      return request.auth != null && request.auth.uid == userId;
    }

    function isAgencyOwner() {
      return request.auth != null && request.auth.token.isAgencyOwner == true;
    }

    function isOwnerOfAgency(agencyId) {
        return request.auth != null && request.auth.token.agencyId == agencyId;
    }
    
    function isOwnerOfContract(contractId) {
      let contractData = get(/databases/$(database)/documents/contracts/$(contractId)).data;
      return isOwner(contractData.userId) || (contractData.ownerType == 'agency' && isOwnerOfAgency(contractData.ownerId));
    }

    // User profiles are public readable, but only the owner can write.
    match /users/{userId} {
      allow read;
      allow write: if isOwner(userId);
    }
    
    // Agencies can be read by any authenticated user, but only updated by the owner
    match /agencies/{agencyId} {
        allow read: if request.auth != null;
        allow create, update: if isOwner(resource.data.ownerId);
    }
    
    // Shared versions can be read by anyone, but only created by the contract owner.
    match /sharedContractVersions/{versionId} {
        allow read: if true;
        allow create: if isOwnerOfContract(request.resource.data.originalContractId);
        allow update, delete: if isOwnerOfContract(resource.data.originalContractId);
    }
    
    // Brands can comment on shared contracts. Only creator can delete.
    match /contractComments/{commentId} {
      allow create: if true;
      allow update, delete: if isOwnerOfContract(resource.data.originalContractId);
    }
    
    match /redlineProposals/{proposalId} {
      allow create: if true; // Brands can create proposals
      allow update, delete: if isOwnerOfContract(resource.data.originalContractId); // Only creator can accept/reject/delete
    }

    // Contracts can only be accessed by their owner or the agency that owns them.
    match /contracts/{contractId} {
        // Correctly handle list queries for both personal and agency contracts
        allow list: if (request.auth != null && 
                      (request.query.where.find(w => w.fieldPath == 'userId' && w.op == '==' && w.value == request.auth.uid) != null)) || 
                     (isAgencyOwner() && 
                      request.query.where.find(w => w.fieldPath == 'ownerId' && w.op == '==' && w.value == request.auth.token.agencyId) != null);
        allow get, update, delete: if isOwnerOfContract(contractId);
        allow create: if isOwner(request.resource.data.userId);
    }

    // Payouts can be read by the agency owner or the talent receiving it.
    match /internalPayouts/{payoutId} {
        allow read: if isOwner(resource.data.agencyOwnerId) || isOwner(resource.data.talentId);
        allow list: if (isAgencyOwner() && request.query.where.find(w => w.fieldPath == 'agencyId' && w.op == '==' && w.value == request.auth.token.agencyId) != null) ||
                     (request.auth != null && request.query.where.find(w => w.fieldPath == 'talentId' && w.op == '==' && w.value == request.auth.uid) != null);
        allow create: if isOwner(request.resource.data.agencyOwnerId);
    }

    // Receipts can only be accessed by the user who owns them.
    match /receipts/{receiptId} {
        allow read, write, delete: if isOwner(request.resource.data.userId);
        allow list: if isOwner(request.query.where[0][2]);
    }
    
    // Agency Invitations can be read/written during the invitation process.
    match /agencyInvitations/{email} {
      allow read, write: if request.auth != null;
    }
    
    // Email logs can only be read by the owner of the associated contract.
    match /emailLogs/{logId} {
        allow read: if isOwnerOfContract(resource.data.contractId);
        allow create: if isOwner(request.resource.data.userId);
    }
  }
}