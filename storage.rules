rules_version = '2';

service firebase.storage {
  match /b/{bucket}/o { // This matches all files in your bucket

    // Helper function to check if a user is an agency owner
    function isAgencyOwner(agencyId, userId) {
      return exists(/databases/$(database)/documents/agencies/$(agencyId)) &&
             get(/databases/$(database)/documents/agencies/$(agencyId)).data.ownerId == userId;
    }

    // Rules for user avatars
    match /avatars/{userId}/{allPaths=**} {
      // Allow public read for avatars (common for profile pictures)
      allow read: if true;
      // Allow authenticated users to write only to their own avatar path
      // And add some constraints on size and type
      allow write: if request.auth != null && request.auth.uid == userId
                   && request.resource.size < 2 * 1024 * 1024 // Max 2MB
                   && request.resource.contentType.matches('image/.*'); // Only image types
    }

    // Rules for contract files - ownerId can be a userId or an agencyId
    match /contracts/{ownerId}/{fileName} {
      // Allow read access if the user is the direct owner OR if they are a member of the agency that owns the contract
      // A more robust check might involve reading the contract document in Firestore to see who the talent is.
      // For now, we grant read access to the owner (user or agency owner). Talent access is managed via contract document rules.
      allow read: if request.auth != null && (request.auth.uid == ownerId || isAgencyOwner(ownerId, request.auth.uid));

      // Allow write access if the user is uploading to their own folder,
      // OR if they are an agency owner uploading to their agency's folder.
      allow write: if request.auth != null
                   && (request.auth.uid == ownerId || isAgencyOwner(ownerId, request.auth.uid))
                   && request.resource.size < 10 * 1024 * 1024 // Max 10MB for contracts
                   && (
                     request.resource.contentType.matches('application/pdf') ||
                     request.resource.contentType.matches('application/msword') ||
                     request.resource.contentType.matches('application/vnd.openxmlformats-officedocument.wordprocessingml.document') ||
                     request.resource.contentType.matches('text/plain') ||
                     request.resource.contentType.matches('image/jpeg') ||
                     request.resource.contentType.matches('image/png')
                   );
    }
    
    // Rules for receipt images
    match /receipts/{userId}/{fileName} {
      // Allow an authenticated user to read their own receipt images
      allow read: if request.auth != null && request.auth.uid == userId;

      // Allow an authenticated user to write (upload, update, delete) their own receipt images
      // with constraints on file size and type
      allow write: if request.auth != null && request.auth.uid == userId
                   && request.resource.size < 5 * 1024 * 1024 // Max 5MB for receipts
                   && (
                     request.resource.contentType.matches('image/.*') ||
                     request.resource.contentType.matches('application/pdf')
                    );
    }
    
    // Rules for generated contract HTML files for e-signature
    match /generated-contracts/{contractId}/{fileName} {
      // This path is written to by backend functions only, so client write is disallowed.
      // Read access should be handled via signed URLs generated by the backend, so direct client read is also not needed.
      allow read, write: if false;
    }
  }
}
